/***************************************************
*
* cismet GmbH, Saarbruecken, Germany
*
*              ... and it just works.
*
****************************************************/
/*
 * DbWriterDialog.java
 *
 * Created on 24. M\u00E4rz 2005, 10:46
 */
package de.cismet.tools.gui.dbwriter;

import java.awt.Color;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

import java.util.Iterator;
import java.util.Vector;

import javax.swing.JOptionPane;

import de.cismet.tools.ConnectionInfo;

/**
 * DOCUMENT ME!
 *
 * @author   hell
 * @version  $Revision$, $Date$
 */
public class DbWriterDialog extends javax.swing.JDialog {

    //~ Static fields/initializers ---------------------------------------------

    protected static final boolean DEBUG_MODE = false;

    //~ Instance fields --------------------------------------------------------

    private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
    private ConnectionInfo connectionInfo;
    private javax.swing.ImageIcon db;
    private javax.swing.ImageIcon ok;
    private javax.swing.ImageIcon error;
    private boolean hasError = false;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox chkAutoClose;
    private javax.swing.JButton cmdDetails;
    private javax.swing.JLabel lblStatus;
    private javax.swing.JPanel panDetails;
    private javax.swing.JPanel panErrors;
    private javax.swing.JPanel panProgress;
    private javax.swing.JPanel panTasks;
    private javax.swing.JProgressBar prbMain;
    private javax.swing.JScrollPane scpErrors;
    private javax.swing.JScrollPane scpTasks;
    private javax.swing.JSeparator sep1;
    private javax.swing.JTable tblTasks;
    private javax.swing.JTabbedPane tbpDetails;
    private javax.swing.JEditorPane txtErrors;
    // End of variables declaration//GEN-END:variables

    //~ Constructors -----------------------------------------------------------

    /**
     * Creates new form DbWriterDialog.
     *
     * @param  parent  DOCUMENT ME!
     * @param  modal   DOCUMENT ME!
     */
    public DbWriterDialog(final java.awt.Frame parent, final boolean modal) {
        super(parent, modal);
        initComponents();
        db = new javax.swing.ImageIcon(getClass().getResource("/de/cismet/tools/gui/dbwriter/res/db.png"));
        ok = new javax.swing.ImageIcon(getClass().getResource("/de/cismet/tools/gui/dbwriter/res/ok.png"));
        error = new javax.swing.ImageIcon(getClass().getResource("/de/cismet/tools/gui/dbwriter/res/error.png"));
        showDetails(false);
    }

    //~ Methods ----------------------------------------------------------------

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    private void initComponents() {                                              //GEN-BEGIN:initComponents
        java.awt.GridBagConstraints gridBagConstraints;

        panProgress = new javax.swing.JPanel();
        lblStatus = new javax.swing.JLabel();
        prbMain = new javax.swing.JProgressBar();
        cmdDetails = new javax.swing.JButton();
        chkAutoClose = new javax.swing.JCheckBox();
        panDetails = new javax.swing.JPanel();
        sep1 = new javax.swing.JSeparator();
        tbpDetails = new javax.swing.JTabbedPane();
        panTasks = new javax.swing.JPanel();
        scpTasks = new javax.swing.JScrollPane();
        tblTasks = new javax.swing.JTable();
        panErrors = new javax.swing.JPanel();
        scpErrors = new javax.swing.JScrollPane();
        txtErrors = new javax.swing.JEditorPane();

        getContentPane().setLayout(new java.awt.GridBagLayout());

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("DB Writer");
        panProgress.setLayout(new java.awt.GridBagLayout());

        panProgress.setMinimumSize(new java.awt.Dimension(491, 90));
        panProgress.setOpaque(false);
        panProgress.setPreferredSize(new java.awt.Dimension(557, 90));
        lblStatus.setText("0 von 0 Aufgaben erledigt");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 4, 0);
        panProgress.add(lblStatus, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        panProgress.add(prbMain, gridBagConstraints);

        cmdDetails.setText("<< Details");
        cmdDetails.addActionListener(new java.awt.event.ActionListener() {

                @Override
                public void actionPerformed(final java.awt.event.ActionEvent evt) {
                    cmdDetailsActionPerformed(evt);
                }
            });

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.insets = new java.awt.Insets(0, 9, 0, 0);
        panProgress.add(cmdDetails, gridBagConstraints);

        chkAutoClose.setSelected(true);
        chkAutoClose.setText("Dieses Dialogfeld nach erfolgreicher Beendigung der Aufgaben automatisch schlie\u00dfen");
        chkAutoClose.setFocusPainted(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        panProgress.add(chkAutoClose, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        getContentPane().add(panProgress, gridBagConstraints);

        panDetails.setLayout(new java.awt.BorderLayout());

        sep1.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(1, 1, 5, 1)));
        panDetails.add(sep1, java.awt.BorderLayout.NORTH);

        tbpDetails.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(5, 1, 1, 1)));
        tbpDetails.setOpaque(true);
        tbpDetails.setPreferredSize(new java.awt.Dimension(482, 342));
        tbpDetails.setRequestFocusEnabled(false);
        panTasks.setLayout(new java.awt.BorderLayout());

        panTasks.setRequestFocusEnabled(false);
        scpTasks.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(4, 4, 4, 4)));
        scpTasks.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scpTasks.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        scpTasks.setMaximumSize(new java.awt.Dimension(32767, 200));
        tblTasks.setBackground(new java.awt.Color(236, 233, 216));
        tblTasks.setModel(new javax.swing.table.DefaultTableModel(
                new Object[][] {
                    { null, null, null, null },
                    { null, null, null, null },
                    { null, null, null, null },
                    { null, null, null, null }
                },
                new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
        tblTasks.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN);
        tblTasks.setShowHorizontalLines(false);
        tblTasks.setShowVerticalLines(false);
        scpTasks.setViewportView(tblTasks);

        panTasks.add(scpTasks, java.awt.BorderLayout.CENTER);

        tbpDetails.addTab("Aufgaben", panTasks);

        panErrors.setLayout(new java.awt.BorderLayout());

        scpErrors.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(4, 4, 4, 4)));
        scpErrors.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scpErrors.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        scpErrors.setViewportView(txtErrors);

        panErrors.add(scpErrors, java.awt.BorderLayout.CENTER);

        tbpDetails.addTab("Fehler", panErrors);

        panDetails.add(tbpDetails, java.awt.BorderLayout.CENTER);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        getContentPane().add(panDetails, gridBagConstraints);

        pack();
    } //GEN-END:initComponents

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdDetailsActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_cmdDetailsActionPerformed
        showDetails(!panDetails.isVisible());
    }                                                                              //GEN-LAST:event_cmdDetailsActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  show  DOCUMENT ME!
     */
    private void showDetails(final boolean show) {
        panDetails.setVisible(show);

        pack();
    }

    /**
     * DOCUMENT ME!
     *
     * @param  connectionInfo  DOCUMENT ME!
     */
    public void setConnection(final ConnectionInfo connectionInfo) {
        this.connectionInfo = connectionInfo;
    }

    /**
     * DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    public boolean hasError() {
        return hasError;
    }

    /**
     * DOCUMENT ME!
     *
     * @param  statements  DOCUMENT ME!
     */
    public void write(final Vector statements) {
        this.prbMain.setValue(0);
        this.prbMain.setMaximum(statements.size());
        this.tblTasks.setModel(new DbWriterTableModel(statements));

        tblTasks.getColumnModel().getColumn(0).setPreferredWidth(24);
        tblTasks.getColumnModel().getColumn(0).setMinWidth(24);
        tblTasks.getColumnModel().getColumn(0).setMaxWidth(24);

        final int counter = 0;

        final Thread writerThread = new Thread() {

                @Override
                public void run() {
                    writeToDB(statements);
                }
            };
        writerThread.setPriority(Thread.NORM_PRIORITY);
        writerThread.start();
    }
    /**
     * DOCUMENT ME!
     *
     * @param  counter     DOCUMENT ME!
     * @param  maxCounter  DOCUMENT ME!
     */
    private void refreshProgressBar(final int counter, final int maxCounter) {
        java.awt.EventQueue.invokeLater(new Runnable() {

                @Override
                public void run() {
                    prbMain.setValue(counter);
                    String aufg1;
                    String aufg2;
                    if (counter > 1) {
                        aufg1 = "Aufgaben";
                    } else {
                        aufg1 = "Aufgabe";
                    }

                    if (maxCounter > 1) {
                        aufg2 = "Aufgaben";
                    } else {
                        aufg2 = "Aufgabe";
                    }
                    lblStatus.setText(counter + " " + aufg1 + " von " + maxCounter + " " + aufg2 + " erledigt");
                }
            });
    }

    /**
     * DOCUMENT ME!
     *
     * @param  statements  DOCUMENT ME!
     */
    private void writeToDB(final Vector statements) {
        int counter = 0;
        txtErrors.setText("");
        final Iterator it = statements.iterator();
        try {
            Class.forName(connectionInfo.getDriver());

            log.fatal("Neue Connection");
            final Connection connection = DriverManager.getConnection(connectionInfo.getUrl(),
                    connectionInfo.getUser(),
                    connectionInfo.getPass());
            connection.setAutoCommit(false);
            final Statement stmnt = connection.createStatement();
            String statement = "";
            int timerMs = 1000;
            final ErrorMarker error = new ErrorMarker();
            try {
                stmnt.execute("begin work");
                stmnt.execute("SET datestyle TO iso, european");
                while (it.hasNext()) {
                    final Object next = it.next();
                    if (next instanceof String) {
                        statement = (String)next;
                        log.info(statement);
                        counter++;
                        refreshProgressBar(counter, statements.size());
                        if (!DEBUG_MODE) {
                            stmnt.executeUpdate(statement);
                        }
                    } else if (next instanceof SimpleDbAction) {
                        final SimpleDbAction sdba = ((SimpleDbAction)next);
                        statement = sdba.getStatement();
                        counter++;
                        refreshProgressBar(counter, statements.size());
                        sdba.executeAction(connection);
                    }
                }
                stmnt.execute("commit");
                stmnt.close();
                prbMain.setForeground(Color.green);
            } catch (Throwable e) {
                prbMain.setForeground(Color.red);

                final String fehlermeldung = "Beim Ausf\u00FChren des Statements: \n" + statement
                            + "\ntrat der Fehler\n>>" + e.getMessage() + "<< auf.\n\n"
                            + "Alle gemachten \u00C4nderungen gingen verloren :-(";

                this.txtErrors.setText(fehlermeldung);
                error.setError(true);
                timerMs = 8000;
                // JOptionPane.showMessageDialog(this,"Fehler beim Ausf\u00FChren der Updates.
                // ("+e.getMessage()+")","\u00C4nderungen wurden nicht durchgef\u00FChrt",JOptionPane.ERROR_MESSAGE);
                stmnt.execute("rollback");
                stmnt.close();
            }
            try {
                connection.close();
            } catch (Exception e) {
                log.error("Schliessen der Connection ging schief", e);
            }

            final java.awt.event.ActionListener timerAction = new java.awt.event.ActionListener() {

                    @Override
                    public void actionPerformed(final java.awt.event.ActionEvent event) {
                        prbMain.setForeground(javax.swing.UIManager.getDefaults().getColor("ProgressBar.foreground"));
                        if (chkAutoClose.isSelected() && (!error.hasError())) {
                            dispose();
                        }
                    }
                };

            final javax.swing.Timer timer = new javax.swing.Timer(timerMs, timerAction);
            timer.setRepeats(false);
            timer.start();

            hasError = error.hasError();
        } catch (Exception ex) {
            log.error("FEHLER", ex);
            hasError = true;
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  args  the command line arguments
     */
    public static void main(final String[] args) {
        java.awt.EventQueue.invokeLater(new Runnable() {

                @Override
                public void run() {
                    new DbWriterDialog(new javax.swing.JFrame(), true).setVisible(true);
                }
            });
    }

    //~ Inner Classes ----------------------------------------------------------

    /**
     * DOCUMENT ME!
     *
     * @version  $Revision$, $Date$
     */
    private class ErrorMarker {

        //~ Instance fields ----------------------------------------------------

        boolean error;

        //~ Constructors -------------------------------------------------------

        /**
         * Creates a new ErrorMarker object.
         */
        public ErrorMarker() {
            error = false;
        }

        //~ Methods ------------------------------------------------------------

        /**
         * DOCUMENT ME!
         *
         * @return  DOCUMENT ME!
         */
        public boolean hasError() {
            return error;
        }
        /**
         * DOCUMENT ME!
         *
         * @param  error  DOCUMENT ME!
         */
        public void setError(final boolean error) {
            this.error = error;
        }
    }
}
